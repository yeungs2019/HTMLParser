Websites used:
https://www.geeksforgeeks.org/avl-tree-set-1-insertion/
https://www.geeksforgeeks.org/avl-tree-set-2-deletion/
https://www.geeksforgeeks.org/splay-tree-set-3-delete/?ref=rp
x-axis is size
y-axis is time in seconds

## Performance in the insert AVL vs splay
The performace involving these two trees has a significant run time difference, despite them being both O(log(n)).  With the insert, AVL always tries to keep a balanced height.  For example, whenever a node is added to the AVL tree, it will always self balance to keep a consistent height.  This slows down the log(n) algorithm, causing it to pile up into potentially O(n).  With the splay tree, on the other hand, with an inserted node, it makes the newly inserted node the root of the tree, then it self balances.  The main difference is that AVL balances itself no matter the action taken on it and splay does its balancing act towards the end.

##Performance in the delete AVL vs splay
The performance involving AVL and splay have similar run times, though avl has a spike when removing more elements because it requires find the best root for itself, while splay cares about finding a good height rather a root.  As stated in the insert, it will rebalance itself after it has done its action.  This can potentially lead to a linear tree. 

##Performance overview 
AVL and splay have efficient algorithms that will fun fast.  The main difference is how they operate.  AVL must rebalance itself after every action, while splay rebalances after it finds a good root.  Because of this, splay is favored in both insertion and deletion than AVL.

##Advantages when it comes to splay
Advantages when it comes to splay trees is that it is a self-optimizing tree. After it takes its action of insertion, deletion, or searching, it will move more nodes that are better off being the root.  Compared with other trees, its average case in on par with other self balancing trees like scapegoat, avl, etc.

#Disadvantages when it comes ot splay
Disadvantages when it comes to splay trees is that they can become linear.  When they become linear, they are now considered as linked lists.  Linked Lists (sorted or unsorted) have a O(n) algorithm, which defeats the purpose of the O(log(n)) algorithm of the tree.  Also, when inserting and/or deleting an element at random, additional "splaying" may occur, which will take more time.

##Advantages when it comes to AVL
AVL advantages are that they are a self-balancing tree.  This will almost always guarentee a balanced height of the tree.  It will pivot the nodes as needed in order to traverse through the tree.

##Disadvantages when it comes to AVL
AVL disadvantages is that it must maintain its height consistently every time.  Since it needs to maintain height, it will also rotate frequently, which causes a time deficiency.  It also requires more memory to run because of the multitude of actions it needs to take.  Insertion in the AVL tree is a major disadvantage because it will take more time to "spit" out a tree with the new element.
