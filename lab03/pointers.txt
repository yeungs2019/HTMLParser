Lab 03: Pointers

int x=7, arr[5]={0, 10, 20, 30, 40};
For questions 1-14, the answers are each exactly ONE line of C++ code.  Also, you may assume an previous line of code you wrote are active.

1) Declare a pointer p1 that is initially pointing at x. 
int* p1 = &x;

2) Change the value of x to 62 without using x. 
*p1 = 62;

3) Declare a pointer named p2 pointing at the first item in arr. 
int* p2 = arr;

4) Change the first item in arr to 7 without using arr. 
p2[0] = 7;

5) Change the 3rd value (the 20) in arr to 15 using [ ] and without using arr. 
p2[2] = 15;

6) Change the 4th value (the 30) in arr to 35 without using [ ] and without using arr. 
*(p2 + 3) = 35;

7) Change p2 to point to the third item in arr without using arr. 
p2 = &p2[2]

8) Change the item pointed at by p2 to 77 without using arr. 
*p2 = 77;

9) Write a Boolean expression that returns true iff p1 and p2 are pointing to an equivalent value. 
if(*p1 == *p2);

 
10) Write a Boolean expression that returns true iff p1 and p2 are pointing to the exact same location. 
if(p1 == p2);
 
11) Make p1 point to a dynamically allocated integer (make sure to create that integer!) 
int* p1 = new int;

12) Free the memory at p1. 
delete p1;

13) Make p1 point to a dynamically allocated array of x integers (again, create that array!) 
int* p1 = new int[];

14) Free the memory at p1.
delete[] p1;

15) Describe what is wrong with the following code segment, assuming it is all part of main(). Indicate if something is a compile time or runtime error or just bad programming. Also indicate how you would fix it. Line numbers have been added in ( ) for ease of reference.  There are several things with the code and for full credit you must find all of them.

(1) int *p;
(2) *p=5;
(3) p=new int();
(4) *p=7;
(5) p=new inIt();
(6) *p=9;
(7) delete p;
(8) *p=15;

Problems: 
(1) int *p is fine
(2) Pointer variables are to point to memory adresses, not values
(3) p=new int(); is fine because you are not overloading memory
(4) Because of 3, *p=7 is allowed.
(5) This is invalid because memory has not be deleted yet.
(6) This is ok, but it may cause overflow
(7) Clearing the memory is ok.
(8) Since the pointer is "reset", we cannot assign the pointer another value.















16) (2 points) Describe the difference between function (stack) and dynamic (heap) allocated memory. Why does C++ support both types?

A main difference in these two is that stack allocates and deallocates memory as the program is running or terminating.  Heap has to be cleared manually by the user.  C++ supports both because it gives the user the option to "garbage" collect the data they don't need. C++ is not a memory hog in a sense, so it supports both types.







Due: September 02, 2020 2359
