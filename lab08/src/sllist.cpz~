#ifdef SLLIST_HPP

template<class T>
SLList<T>::SLList() {
}

/* Do a deep copy of sll into the this.
 * Note: This one uses a reference to a Singly Linked List!
 */
template<class T>
SLList<T>::SLList(const SLList<T> &sll) {
}

// free the memory
template<class T>
SLList<T>::~SLList() {
}

// returns length of list
template<class T>
int SLList<T>::getLength() const {
	head* rover = head;
	int currentLength = 0;

	while(rover != NULL) {
		currentLength++;
		rover -> getNext();
	}
	return currentLength;
}

// inserts a node to the end of list
template<class T>
bool SLList<T>::append(const T &val) {
    return false;
}

// prints out SLL
template<class T>
void SLList<T>::print() const {
	for (rover = head; rover != NULL; rover = rover->getNext()){
		std::cout << rover->getData() << ", ";
	}
	std::cout << "\n";
}

/* Insert val at position pos.
 * Return true if successful (it can be placed.)
 * Otherwise return false.
 */
template<class T>
bool SLList<T>::insert(const int pos, T &val) {
    return false;
}

/* Remove the first instance of val
 * Return true if found and removed.
 * Otherwise return false.
 */
template<class T>
bool SLList<T>::remove(const T &val) {
	prev = NULL;
	toDelete = NULL;
	    return false;
}

// retrieves the element at position pos
template<class T>
T& SLList<T>::operator[](const int pos) {
	rover = head;
	for (int i = 0; i < pos; i++){
		rover = rover->getNext();
	}
	return rover->getData();
}

// returns the two lists if they are the same
template<class T>
bool SLList<T>::operator==(const SLList<T> &list) const {
    return false;
}

#endif
