#ifdef SLLIST_HPP
#include<iostream>


template<class T>
SLList<T>::SLList() {
}

/* Do a deep copy of sll into the this.
 * Note: This one uses a reference to a Singly Linked List!
 */
template<class T>
SLList<T>::SLList(const SLList<T> &sll) {
}

// free the memory
template<class T>
SLList<T>::~SLList() {
	/*SLLNode<T>* temp;
	while (head != NULL){
		temp = head;
		head = head->getNext();
		delete temp;
	}
	tail = NULL;
	count = 0;*/
}

// returns length of list
template<class T>
int SLList<T>::getLength() const {
	return length;
}

// inserts a node to the end of list
template<class T>
bool SLList<T>::append(const T &val) {
	/*bool isAppend = false;
	SLLNode<T>* rover = new T(val, NULL);
	rover->getData = val;
	rover->nextNode = NULL;
	if (head == NULL) {
		head = rover;
		tail = rover;
		count++;
	}
	else{
		tail->nextNode = rover;
		tail = rover;
		count++;
	}*/
    return false;
}

// prints out SLL
template<class T>
void SLList<T>::print() const {
	/*SLLNode<T>* rover = NULL;
	rover = head;
	while(rover != NULL) {
		std::cout << rover->getData() << ",";
		rover = rover->nextNode;
	}*/
}

/* Insert val at position pos.
 * Return true if successful (it can be placed.)
 * Otherwise return false.
 */
template<class T>
bool SLList<T>::insert(const int pos, T &val) {
    return false;
}

/* Remove the first instance of val
 * Return true if found and removed.
 * Otherwise return false.
 */
template<class T>
bool SLList<T>::remove(const T &val) {
	/*bool isFound = false;
	SLLNode<T>* rover = NULL;
	for (SLLNode* rover = head; rover != NULL; rover = rover->getNext()){
		if (
	toDelete = NULL;

	    return false;*/
}

// retrieves the element at position pos
template<class T>
T& SLList<T>::operator[](const int pos) {
	SLLNode<T>* rover = head;
	for (int i = 0; i < pos; i++){
		rover = rover->getNext();
	}
	return rover->getData();
}

// returns the two lists if they are the same
template<class T>
bool SLList<T>::operator==(const SLList<T> &list) const {
	/*bool noEquality = false;
	if(this->getLength() != list.getLength()){
		return false;
	}
	for*/
    return false;
}

#endif
